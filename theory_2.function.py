
----------------------------------------------------------- ОСНОВНЫЕ ТЕЗИСЫ --------------------------------------------------------------

- ПОРЯДКОВЫЕ ПЕРЕМЕННЫЕ должны мы вызывать только по ПОРЯДКУ
- ИМЕННЫЕ ПЕРЕМЕННЫЕ можем сетать когда захотим и как НЕ обязательно ПО ПОРЯДКУ 

/ Для передачи неограниченного количества ПОРЯДКОВЫХ ПЕРЕМЕННЫХ используется *args
/ Для передачи неограниченного кол-ва ИМЕНОВАННЫХ ПЕРЕМЕННЫХ используется **kwargs

+ Ответ *args = КОРТЕЖ (ТЮПЛ) это (3, 5, 7, 9) НЕИЗМЕНЯЕМЫЙ СПИСОК
+ Ответ **kwargs = СЛОВАРЬ (тип данных похожий на json) это {'m1': 4, 'm2': 6, 'm3': 9} англ. DICTIONARY (dict.)
  
! ПРАВИЛО: СНАЧАЛА объявляются ПОРЯДКОВЫЕ ПЕРЕМЕННЫЕ, ЗАТЕМ только ИМЕНОВАННЫЕ ПЕРЕМЕННЫЕ

_________________________________________________________________________________________________________________________________________
1. Создать функцию: 
  
def f1(a1, a2, a3):
    v1 = a1 * 2
    return v1
result = f1(2, 3, 4)
print(result)

__________________________________
------------------------------------------------------------------ ПО КУСКАМ: --------------------------------------------------------
  
1.1) def f1(а1, а2, а3):
  
* где:
    - def = функция
    - f1 = название функции, эта функция на вход ожидает 3 параметра = а1, а2, а3
    - а1, а2, а3 = параметры внутри функции

__________________
Внутри функции мы создали переменную v1. Эта переменная берет первый параметр (а1) и * на 2:

1.2) v1 = а1 * 2

________________
Потом словом return мы говорим функции что вернуть когда ее вызвали (вернет она значение которое присвоено этой переменной v1):

1.3) return v1

___________________
Вызов функции:

1.4) result = f1(2, 3, 4)
________

1.5) print(result)

* Потом запускаем

_______________________________________________________________________________________________________________________________________

------------------------------------------------------------------ ДЛЯ ЧЕГО НУЖНЫ ФУНКЦИИ:  -----------------------------------------------------
  
  - В 1 функции могут быть сотни строк кода и кусок кода коорый внутри функции надо использовать раз 5 в нашей программе 
  и что бы не дублировать сотни строк кода которые нам понадобятся мы засовываем этот код в 1 функцию f1(a1, a2, a3) а потом просто вызываем одну строчку с функцией с входными параметрами

------------------------------------------------------------------- ПЕРЕМЕННЫЕ МОГУТ БЫТЬ: ----------------------------------------------------------
  
- 1. Глобальные (global) которые являются как ьы вирткальными (то есть висят где-то в памяти и их можно в любой момент "дернуть")
задача таких переменных поменять то что уже существует при этом ничего не возвращая 
- 2. Локальные (local)


___________________________________________________________________________________________________________________________________________
def f1(a1, a2, a3):
    v1 = a1 * 2
    v2 = a2 * 10
    v3 = a3 * 7

    return v1, v2, v3

r1, r2, r3 = f1(2,3,4)
print(r1, r2, r3)

_____
# АНАЛОГ:

def f1(a1, a2, a3):
    v1 = a1 * 2
    v2 = a2 * 10
    v3 = a3 * 7

    result = [v1,v2,v3]
    return result
f_result = f1(2,3,4)
print(f_result)

__________________________________________
# например вернуть второй элемент из списка:

def f1(a1, a2, a3):
    v1 = a1 * 2
    v2 = a2 * 10
    v3 = a3 * 7

    result = [v1, v2, v3]
    return result


f_result = f1(2, 3, 4)
print(f_result[2])


___________________________________________________________________________________________________________________________________________________

-------------------------------------------------------- *ARGS: ПОРЯДКОВЫЕ ПЕРЕМЕННЫЕ -----------------------------------------------------------
  
- ПОРЯДКОВЫЕ ПЕРЕМЕННЫЕ должны мы вызывать только по ПОРЯДКУ (например а1 и значение в функции и в вызове функции по порядку указываем числа которые мы присваиваем к каждой переменной)

- это называется распаковка, когда не знаешь сколько ты будешь передавать аргументов, то используешь *args (может быть любое слово, но принято писать args)
  
- Функция на вход будет принимать ЛЮБОЕ количество ПОРЯДКОВЫХ элементов или ПОРЯДКОВЫХ ЗНАЧЕНИЙ

- *args по умолчанию возвращает КОРТЕЖ

- *args передает неограниченное количество ПОРЯДКОВЫХ ПЕРЕМЕННЫХ, для передачи неограниченного кол-ва ИМЕНОВАННЫХ ПЕРЕМЕННЫХ используется KWARGS

______

def f2(*args):
    
    print(args)

f2(3, 5, 7, 9)

ОТВЕТ: (3, 5, 7, 9)

Данные в скобках называются КОРТЕЖ = НЕИЗМЕНЯЕМЫЙ СПИСОК (англ. ТЮПЛ)
_____________________

def f2(*args):

    print(args)

    return(args)

nn = f2(3, 5, 7, 9)
print(nn)

ОТВЕТ: (3, 5, 7, 9)
       (3, 5, 7, 9)
    
____________________________________________________________________________________________________________________________________________________________

-------------------------------------------------------------------------- ИМЕННОВАННЫЕ ПЕРЕМЕННЫЕ --------------------------------------------------------------

1. ПОРЯДКОВЫЕ ПЕРЕМЕННЫЕ должны мы вызывать только по ПОРЯДКУ (например а1 и значение в функции и в вызове функции по порядку указываем числа которые мы присваиваем к каждой переменной)
2. ИМЕННЫЕ ПЕРЕМЕННЫЕ можем сетать когда захотим и как НЕ обязательно ПО ПОРЯДКУ 

____________
def f1(a1, a2, a3, a4=100, a5=200, a6="July"):

    v1 = a1 * 2
    v2 = a2 * 10
    v3 = a3 * 7
    v4 = a4+a3
    v5 = a5

    result = [v1, v2, v3, v4, v5]
    return result
  
r1, r2, r3, r4, r5 = f1(2, 3, 4, a5=500)
print(r1, r2, r3, r4, r5)

* Тут хоть у нас а5 в def f1 = 200, но в ВЫПОЛНЕНИИ ФУНКЦИИ мы указали что а5=500, то в ответе будет 500

ОТВЕТ: 4 30 28 104 500

______________________
обычно в переменные напимер а5 по умолчанию ставят None (дабы не хардкодить и не было путанницы), то есть

def f1(a1, a2, a3, a4=100, a5=None, a6="July"):

    v1 = a1 * 2
    v2 = a2 * 10
    v3 = a3 * 7
    v4 = a4+a3
    v5 = a5

    result = [v1, v2, v3, v4, v5]
    return result
  
r1, r2, r3, r4, r5 = f1(2, 3, 4)
print(r1, r2, r3, r4, r5)

_____________________________________________________________________________________________________________________________

----------------------------------------------- ПЕРЕДАЧА НЕОГРАНИЧЕННОГО КОЛИЧЕСТВА ИМЕНОВАННЫХ ПЕРЕМЕННЫХ. **KWARGS -------------------------------------------------

- Для передачи неограниченного кол-ва ИМЕНОВАННЫХ ПЕРЕМЕННЫХ используется **kwargs

Таким образом:
  * a1, a2, a3 это можно считать args
  * a4=100, a5=200, a6="July" это можно считать kwargs 

_________________
def f3(**kwargs):

    print(kwargs)

f3(m1=4, m2=6, m3=9)

ОТВЕТ: {'m1': 4, 'm2': 6, 'm3': 9}

____________________________________________________________________________________________________________________________________________________

------------------------------------------------------------------------- ИТОГ И ОТЛИЧИЯ ---------------------------------------------------------------

1. Ответ *args = КОРТЕЖ (ТЮПЛ) это (3, 5, 7, 9) НЕИЗМЕНЯЕМЫЙ СПИСОК
   Ответ **kwargs = СЛОВАРЬ (тип данных похожий на json) это {'m1': 4, 'm2': 6, 'm3': 9} англ. DICTIONARY (dict.)
  
2. ПРАВИЛО: СНАЧАЛА объявляются ПОРЯДКОВЫЕ ПЕРЕМЕННЫЕ, ЗАТЕМ только ИМЕНОВАННЫЕ ПЕРЕМЕННЫЕ
  
___________________________________
Функция, которая на вход принимает все (и какую-то переменную, и неограниченный список порядковых элементов и неограниченный список ИМЕННЫХ ПЕРЕМЕННЫХ)

def f4(*args, **kwargs):
    print(args)
    print(kwargs)

f4(5,7,0, k1=99, k2=88)

ОТВЕТ: (5, 7, 0)
       {'k1': 99, 'k2': 88}
 
_______________________________________

def f4(salary, *args, **kwargs):
    print(args)
    print(kwargs)
    print(salary)

f4(5,7,0, k1=99, k2=88)

ОТВЕТ: (7, 0)
       {'k1': 99, 'k2': 88}
       5
      
!!!!!!!!!!!!!!!!!!!! ТУТ salary будет равно 5!!!!!!!!!!!!!

 
                                                          
